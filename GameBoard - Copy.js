// Generated by CoffeeScript 1.12.7
var GameBoard;

GameBoard = (function() {
  GameBoard.prototype.numRows = 4;

  GameBoard.prototype.numCols = 13;

  function GameBoard(playingCards) {
    this.playingCards = playingCards;
    this.board = [];
    this.cardLookup = [];
    this.turns = 0;
    this.fixForNegativeNos = 4;
  }

  GameBoard.prototype.clone = function() {
    var newBoard;
    newBoard = new GameBoard(this.playingCards);
    newBoard.board = this.board.slice(0);
    newBoard.cardLookup = this.cardLookup.slice(0);
    newBoard.turns = this.turns;
    return newBoard;
  };

  GameBoard.prototype.copy = function(copyFrom) {
    this.board = copyFrom.board.slice(0);
    this.cardLookup = copyFrom.cardLookup.slice(0);
    this.turns = copyFrom.turns;
    return true;
  };

  GameBoard.prototype.deal = function() {
    var cardId, idx, j, n, ref;
    this.board = [];
    this.cardLookup = (function() {
      var j, ref, results;
      results = [];
      for (n = j = 0, ref = this.playingCards.cardsInDeck - 1; 0 <= ref ? j <= ref : j >= ref; n = 0 <= ref ? ++j : --j) {
        results.push(0);
      }
      return results;
    }).call(this);
    this.playingCards.startDeal();
    for (idx = j = 0, ref = this.playingCards.cardsInDeck - 1; 0 <= ref ? j <= ref : j >= ref; idx = 0 <= ref ? ++j : --j) {
      cardId = this.playingCards.getNextCard();
      this.board.push(cardId);
      this.cardLookup[cardId] = idx;
    }
    return true;
  };

  GameBoard.prototype.removeAces = function() {
    var cardId, gapCardId, idx, j, ref, results;
    gapCardId = -1;
    results = [];
    for (idx = j = 0, ref = this.playingCards.cardsInDeck - 1; 0 <= ref ? j <= ref : j >= ref; idx = 0 <= ref ? ++j : --j) {
      cardId = this.board[idx];
      if (this.playingCards.getCardInfo(cardId).rankIdx === this.playingCards.AceId) {
        this.board[idx] = gapCardId;
        results.push(gapCardId -= 1);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  GameBoard.prototype.redeal = function() {
    var boardLocnIdx, cardId, cardInfo, cardLocnIdx, colIdx, colsToRedealFrom, deck, j, k, l, m, o, p, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, rowIdx, suitIdxForRow;
    colsToRedealFrom = [];
    for (rowIdx = j = 0, ref = this.numRows - 1; 0 <= ref ? j <= ref : j >= ref; rowIdx = 0 <= ref ? ++j : --j) {
      suitIdxForRow = -1;
      for (colIdx = k = 0, ref1 = this.numCols - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; colIdx = 0 <= ref1 ? ++k : --k) {
        cardId = this.board[rowIdx * this.numCols + colIdx];
        cardInfo = this.playingCards.getCardInfo(cardId);
        if (colIdx === 0) {
          suitIdxForRow = cardInfo.suitIdx;
        }
        if (cardInfo.isGap || cardInfo.rankIdx - 1 !== colIdx || cardInfo.suitIdx !== suitIdxForRow) {
          colsToRedealFrom.push(colIdx);
          break;
        }
      }
    }
    deck = new PlayingCards();
    deck.empty();
    for (rowIdx = l = 0, ref2 = this.numRows - 1; 0 <= ref2 ? l <= ref2 : l >= ref2; rowIdx = 0 <= ref2 ? ++l : --l) {
      for (colIdx = m = ref3 = colsToRedealFrom[rowIdx], ref4 = this.numCols - 1; ref3 <= ref4 ? m <= ref4 : m >= ref4; colIdx = ref3 <= ref4 ? ++m : --m) {
        cardId = this.board[rowIdx * this.numCols + colIdx];
        if (cardId >= 0) {
          deck.addCard(cardId);
        }
      }
    }
    deck.shuffle();
    deck.startDeal();
    for (rowIdx = o = 0, ref5 = this.numRows - 1; 0 <= ref5 ? o <= ref5 : o >= ref5; rowIdx = 0 <= ref5 ? ++o : --o) {
      boardLocnIdx = rowIdx * this.numCols + colsToRedealFrom[rowIdx];
      this.board[boardLocnIdx] = -rowIdx - 1;
      this.cardLookup[rowIdx] = boardLocnIdx;
      if (colsToRedealFrom[rowIdx] + 1 < this.numCols) {
        for (colIdx = p = ref6 = colsToRedealFrom[rowIdx] + 1, ref7 = this.numCols - 1; ref6 <= ref7 ? p <= ref7 : p >= ref7; colIdx = ref6 <= ref7 ? ++p : --p) {
          cardId = deck.getNextCard();
          if (cardId >= 0) {
            cardLocnIdx = rowIdx * this.numCols + colIdx;
            this.board[cardLocnIdx] = cardId;
            this.cardLookup[cardId] = cardLocnIdx;
          }
        }
      }
    }
    this.turns += 1;
    return true;
  };

  GameBoard.prototype.getCardId = function(rowIdx, colIdx) {
    return this.board[rowIdx * this.numCols + colIdx];
  };

  GameBoard.prototype.getCardFileName = function(rowIdx, colIdx) {
    var cardId;
    cardId = this.board[rowIdx * this.numCols + colIdx];
    return this.playingCards.getCardFileName(cardId);
  };

  GameBoard.prototype.getCardToLeftInfo = function(cardId) {
    var cardLocnIdx, colIdx, rowIdx;
    if (cardId < 0) {
      cardId += this.fixForNegativeNos;
    }
    cardLocnIdx = this.cardLookup[cardId];
    colIdx = cardLocnIdx % this.numCols;
    rowIdx = Math.floor(cardLocnIdx / this.numRows);
    if (colIdx === 0) {
      return [-1, rowIdx, colIdx, 0, 0];
    }
    return [this.board[rowIdx * this.numCols + colIdx - 1], rowIdx, colIdx, rowIdx, colIdx - 1];
  };

  GameBoard.prototype.getLocnOfCard = function(cardId) {
    var cardLocnIdx, colIdx, rowIdx;
    if (cardId < 0) {
      cardId += this.fixForNegativeNos;
    }
    cardLocnIdx = this.cardLookup[cardId];
    colIdx = cardLocnIdx % this.numCols;
    rowIdx = Math.floor(cardLocnIdx / this.numRows);
    return [true, rowIdx, colIdx];
  };

  GameBoard.prototype.getEmptySquares = function() {
    var cardLocnIdx, colIdx, emptySqList, i, j, ref, rowIdx;
    emptySqList = [];
    for (i = j = 0, ref = this.numRows - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      cardLocnIdx = this.cardLookup[i];
      colIdx = cardLocnIdx % this.numCols;
      rowIdx = Math.floor(cardLocnIdx / this.numRows);
      emptySqList.push([rowIdx, colIdx]);
    }
    return emptySqList;
  };

  GameBoard.prototype.getValidMovesForEmptySq = function(toCardId) {
    var cardCol, cardLocn, cardRow, cardToLeftId, cardToMove, j, nextCard, ref, spaceCol, spaceRow, suitIdx, validMoves;
    validMoves = [];
    ref = this.getCardToLeftInfo(toCardId), cardToLeftId = ref[0], spaceRow = ref[1], spaceCol = ref[2], cardRow = ref[3], cardCol = ref[4];
    if (cardToLeftId === -1 && spaceCol === 0) {
      for (suitIdx = j = 0; j <= 3; suitIdx = ++j) {
        cardToMove = this.playingCards.getCardId(suitIdx, this.playingCards.TwoId);
        if (cardToMove >= 0) {
          cardLocn = this.getLocnOfCard(cardToMove);
          if (cardLocn[2] !== 0) {
            validMoves.push([[cardLocn[1], cardLocn[2]], [spaceRow, spaceCol]]);
          }
        }
      }
    } else if (cardToLeftId >= 0) {
      nextCard = this.playingCards.findNextCardInSameSuit(cardToLeftId);
      cardLocn = this.getLocnOfCard(nextCard);
      if (nextCard >= 0) {
        validMoves.push([[cardLocn[1], cardLocn[2]], [spaceRow, spaceCol]]);
      }
    }
    return validMoves;
  };

  GameBoard.prototype.moveValidCardToEmptyPlace = function(toCardId) {
    var cardCol, cardRow, cardToLeftId, clickedCol, clickedRow, fromCardId, ref;
    if (toCardId < 0) {
      ref = this.getCardToLeftInfo(toCardId), cardToLeftId = ref[0], clickedRow = ref[1], clickedCol = ref[2], cardRow = ref[3], cardCol = ref[4];
      if (cardToLeftId === -1) {
        return ["select2", 0, 0, clickedRow, clickedCol];
      }
      if (cardToLeftId >= 0) {
        fromCardId = this.playingCards.findNextCardInSameSuit(cardToLeftId);
        if (fromCardId > 0) {
          return this.moveCard(fromCardId, toCardId);
        }
      }
    }
    return ["none", 0, 0, 0, 0];
  };

  GameBoard.prototype.moveCardIfValid = function(fromCardId, toCardId) {
    var cardCol, cardRow, cardToLeftId, clickedCol, clickedRow, moveOk, ok, ref, ref1, toColIdx, toRowIdx;
    if (toCardId < 0) {
      moveOk = false;
      if (this.playingCards.getCardInfo(fromCardId).rankIdx === this.playingCards.TwoId) {
        ref = this.getLocnOfCard(toCardId), ok = ref[0], toRowIdx = ref[1], toColIdx = ref[2];
        if (ok && toColIdx === 0) {
          moveOk = true;
        }
      } else {
        ref1 = this.getCardToLeftInfo(toCardId), cardToLeftId = ref1[0], clickedRow = ref1[1], clickedCol = ref1[2], cardRow = ref1[3], cardCol = ref1[4];
        if (cardToLeftId >= 0) {
          if (fromCardId === this.playingCards.findNextCardInSameSuit(cardToLeftId)) {
            moveOk = true;
          }
        }
      }
      if (moveOk) {
        return this.moveCard(fromCardId, toCardId);
      }
    }
    return ["none", 0, 0, 0, 0];
  };

  GameBoard.prototype.moveCard = function(fromCardId, toCardId) {
    var cardId, cardLocnIdx, fromColIdx, fromRowIdx, gapId, gapLocnIdx, ok, ref, ref1, toColIdx, toRowIdx;
    ref = this.getLocnOfCard(fromCardId), ok = ref[0], fromRowIdx = ref[1], fromColIdx = ref[2];
    if (ok) {
      ref1 = this.getLocnOfCard(toCardId), ok = ref1[0], toRowIdx = ref1[1], toColIdx = ref1[2];
      if (ok) {
        gapLocnIdx = toRowIdx * this.numCols + toColIdx;
        gapId = this.board[gapLocnIdx];
        cardLocnIdx = fromRowIdx * this.numCols + fromColIdx;
        cardId = this.board[gapLocnIdx] = this.board[cardLocnIdx];
        this.board[cardLocnIdx] = gapId;
        this.cardLookup[cardId] = gapLocnIdx;
        this.cardLookup[gapId + this.fixForNegativeNos] = cardLocnIdx;
        return ["ok", fromRowIdx, fromColIdx, toRowIdx, toColIdx];
      }
    }
    return ["none", 0, 0, 0, 0];
  };

  GameBoard.prototype.moveCardUsingRowAndColInfo = function(fromRowCol, toRowCol) {
    var cardId, cardLocnIdx, gapId, gapLocnIdx;
    gapLocnIdx = toRowCol[0] * this.numCols + toRowCol[1];
    gapId = this.board[gapLocnIdx];
    cardLocnIdx = fromRowCol[0] * this.numCols + fromRowCol[1];
    cardId = this.board[gapLocnIdx] = this.board[cardLocnIdx];
    this.board[cardLocnIdx] = gapId;
    this.cardLookup[cardId] = gapLocnIdx;
    this.cardLookup[gapId + this.fixForNegativeNos] = cardLocnIdx;
    return ["ok", fromRowCol[0], fromRowCol[1], toRowCol[0], toRowCol[1]];
  };

  GameBoard.prototype.getCardName = function(cardId) {};

  GameBoard.prototype.debugDump = function(debugStr) {
    var cardInfo, col, j, k, ref, ref1, results, row, rowStr;
    console.log(debugStr);
    results = [];
    for (row = j = 0, ref = this.numRows - 1; 0 <= ref ? j <= ref : j >= ref; row = 0 <= ref ? ++j : --j) {
      rowStr = "";
      for (col = k = 0, ref1 = this.numCols - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; col = 0 <= ref1 ? ++k : --k) {
        cardInfo = this.playingCards.getCardInfo(this.getCardId(row, col));
        rowStr += cardInfo.cardShortName + " ";
      }
      results.push(console.log(rowStr));
    }
    return results;
  };

  GameBoard.prototype.getBoardScore = function() {
    var cardId, col, completeRows, factoredScore, j, k, kingLastColumns, kingSpaces, l, lastCardWasKing, m, rawScore, ref, ref1, ref2, ref3, row, rowSuit;
    rawScore = 0;
    completeRows = 0;
    for (row = j = 0, ref = this.numRows - 1; 0 <= ref ? j <= ref : j >= ref; row = 0 <= ref ? ++j : --j) {
      rowSuit = -1;
      for (col = k = 0, ref1 = this.numCols - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; col = 0 <= ref1 ? ++k : --k) {
        cardId = this.getCardId(row, col);
        if (col === 0) {
          if (this.playingCards.getCardRank(cardId) === this.playingCards.TwoId) {
            rowSuit = this.playingCards.getCardSuit(cardId);
            rawScore++;
          } else {
            break;
          }
        } else {
          if (this.playingCards.getCardRank(cardId) === col + 1 && this.playingCards.getCardSuit(cardId) === rowSuit) {
            rawScore++;
            if (col === this.numCols - 1) {
              completeRows++;
            }
          } else {
            break;
          }
        }
      }
    }
    kingSpaces = 0;
    kingLastColumns = 0;
    for (row = l = 0, ref2 = this.numRows - 1; 0 <= ref2 ? l <= ref2 : l >= ref2; row = 0 <= ref2 ? ++l : --l) {
      lastCardWasKing = false;
      for (col = m = 0, ref3 = this.numCols - 1; 0 <= ref3 ? m <= ref3 : m >= ref3; col = 0 <= ref3 ? ++m : --m) {
        cardId = this.getCardId(row, col);
        if (this.playingCards.getCardRank(cardId) === this.playingCards.KingId) {
          if (col === this.numCols - 1) {
            kingLastColumns++;
          } else {
            lastCardWasKing = true;
          }
        } else {
          if (cardId < 0 && lastCardWasKing) {
            kingSpaces++;
          }
          lastCardWasKing = false;
        }
      }
    }
    if (completeRows === 4) {
      factoredScore = 100;
    } else {
      factoredScore = rawScore - kingSpaces + kingLastColumns + completeRows * 5;
    }
    return [factoredScore, rawScore];
  };

  return GameBoard;

})();

//# sourceMappingURL=GameBoard - Copy.js.map
