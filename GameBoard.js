// Generated by CoffeeScript 1.12.7
var GameBoard;

GameBoard = (function() {
  GameBoard.prototype.numRows = 4;

  GameBoard.prototype.numCols = 13;

  function GameBoard(playingCards) {
    this.playingCards = playingCards;
    this.board = [];
    this.turns = 0;
  }

  GameBoard.prototype.copy = function(copyFrom) {
    this.board = copyFrom.board.slice(0);
    this.turns = copyFrom.turns;
    return true;
  };

  GameBoard.prototype.deal = function() {
    var i, idx, ref;
    this.board = [];
    this.playingCards.startDeal();
    for (idx = i = 0, ref = this.playingCards.cardsInDeck - 1; 0 <= ref ? i <= ref : i >= ref; idx = 0 <= ref ? ++i : --i) {
      this.board.push(this.playingCards.getNextCard());
    }
    return true;
  };

  GameBoard.prototype.removeAces = function() {
    var cardId, gapCardId, i, idx, ref, results;
    gapCardId = -1;
    results = [];
    for (idx = i = 0, ref = this.playingCards.cardsInDeck - 1; 0 <= ref ? i <= ref : i >= ref; idx = 0 <= ref ? ++i : --i) {
      cardId = this.board[idx];
      if (this.playingCards.getCardInfo(cardId).rankIdx === this.playingCards.AceId) {
        this.board[idx] = gapCardId;
        results.push(gapCardId -= 1);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  GameBoard.prototype.redeal = function() {
    var cardId, cardInfo, colIdx, colsToRedealFrom, deck, i, j, k, l, m, n, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, rowIdx, suitIdxForRow;
    colsToRedealFrom = [];
    for (rowIdx = i = 0, ref = this.numRows - 1; 0 <= ref ? i <= ref : i >= ref; rowIdx = 0 <= ref ? ++i : --i) {
      suitIdxForRow = -1;
      for (colIdx = j = 0, ref1 = this.numCols - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; colIdx = 0 <= ref1 ? ++j : --j) {
        cardId = this.board[rowIdx * this.numCols + colIdx];
        cardInfo = this.playingCards.getCardInfo(cardId);
        if (colIdx === 0) {
          suitIdxForRow = cardInfo.suitIdx;
        }
        if (cardInfo.isGap || cardInfo.rankIdx - 1 !== colIdx || cardInfo.suitIdx !== suitIdxForRow) {
          colsToRedealFrom.push(colIdx);
          break;
        }
      }
    }
    deck = new PlayingCards();
    deck.empty();
    for (rowIdx = k = 0, ref2 = this.numRows - 1; 0 <= ref2 ? k <= ref2 : k >= ref2; rowIdx = 0 <= ref2 ? ++k : --k) {
      for (colIdx = l = ref3 = colsToRedealFrom[rowIdx], ref4 = this.numCols - 1; ref3 <= ref4 ? l <= ref4 : l >= ref4; colIdx = ref3 <= ref4 ? ++l : --l) {
        cardId = this.board[rowIdx * this.numCols + colIdx];
        if (cardId >= 0) {
          deck.addCard(cardId);
        }
      }
    }
    deck.shuffle();
    deck.startDeal();
    for (rowIdx = m = 0, ref5 = this.numRows - 1; 0 <= ref5 ? m <= ref5 : m >= ref5; rowIdx = 0 <= ref5 ? ++m : --m) {
      this.board[rowIdx * this.numCols + colsToRedealFrom[rowIdx]] = -rowIdx - 1;
      if (colsToRedealFrom[rowIdx] + 1 < this.numCols) {
        for (colIdx = n = ref6 = colsToRedealFrom[rowIdx] + 1, ref7 = this.numCols - 1; ref6 <= ref7 ? n <= ref7 : n >= ref7; colIdx = ref6 <= ref7 ? ++n : --n) {
          cardId = deck.getNextCard();
          if (cardId >= 0) {
            this.board[rowIdx * this.numCols + colIdx] = cardId;
          }
        }
      }
    }
    this.turns += 1;
    return true;
  };

  GameBoard.prototype.getCardId = function(rowIdx, colIdx) {
    return this.board[rowIdx * this.numCols + colIdx];
  };

  GameBoard.prototype.getCardFileName = function(rowIdx, colIdx) {
    var cardId;
    cardId = this.board[rowIdx * this.numCols + colIdx];
    return this.playingCards.getCardFileName(cardId);
  };

  GameBoard.prototype.getCardToLeftInfo = function(cardId) {
    var chkCardId, colIdx, i, j, ref, ref1, rowIdx;
    for (rowIdx = i = 0, ref = this.numRows - 1; 0 <= ref ? i <= ref : i >= ref; rowIdx = 0 <= ref ? ++i : --i) {
      for (colIdx = j = 0, ref1 = this.numCols - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; colIdx = 0 <= ref1 ? ++j : --j) {
        chkCardId = this.board[rowIdx * this.numCols + colIdx];
        if (chkCardId === cardId) {
          if (colIdx === 0) {
            return [-1, rowIdx, colIdx, 0, 0];
          }
          return [this.board[rowIdx * this.numCols + colIdx - 1], rowIdx, colIdx, rowIdx, colIdx - 1];
        }
      }
    }
    return [-2, 0, 0, 0, 0];
  };

  GameBoard.prototype.getLocnOfCard = function(cardId) {
    var chkCardId, colIdx, i, j, ref, ref1, rowIdx;
    for (rowIdx = i = 0, ref = this.numRows - 1; 0 <= ref ? i <= ref : i >= ref; rowIdx = 0 <= ref ? ++i : --i) {
      for (colIdx = j = 0, ref1 = this.numCols - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; colIdx = 0 <= ref1 ? ++j : --j) {
        chkCardId = this.board[rowIdx * this.numCols + colIdx];
        if (chkCardId === cardId) {
          return [true, rowIdx, colIdx];
        }
      }
    }
    return [false, 0, 0];
  };

  GameBoard.prototype.getEmptySquares = function() {
    var chkCardId, colIdx, emptySqList, i, j, ref, ref1, rowIdx;
    emptySqList = [];
    for (rowIdx = i = 0, ref = this.numRows - 1; 0 <= ref ? i <= ref : i >= ref; rowIdx = 0 <= ref ? ++i : --i) {
      for (colIdx = j = 0, ref1 = this.numCols - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; colIdx = 0 <= ref1 ? ++j : --j) {
        chkCardId = this.board[rowIdx * this.numCols + colIdx];
        if (chkCardId < 0) {
          emptySqList.push([rowIdx, colIdx]);
        }
      }
    }
    return emptySqList;
  };

  GameBoard.prototype.getValidMovesForEmptySq = function(toCardId) {
    var cardCol, cardLocn, cardRow, cardToLeftId, cardToMove, i, nextCard, ref, spaceCol, spaceRow, suitIdx, validMoves;
    validMoves = [];
    ref = this.getCardToLeftInfo(toCardId), cardToLeftId = ref[0], spaceRow = ref[1], spaceCol = ref[2], cardRow = ref[3], cardCol = ref[4];
    if (cardToLeftId === -1 && spaceCol === 0) {
      for (suitIdx = i = 0; i <= 3; suitIdx = ++i) {
        cardToMove = this.playingCards.getCardId(suitIdx, this.playingCards.TwoId);
        if (cardToMove >= 0) {
          cardLocn = this.getLocnOfCard(cardToMove);
          if (cardLocn[2] !== 0) {
            validMoves.push([[cardLocn[1], cardLocn[2]], [spaceRow, spaceCol]]);
          }
        }
      }
    } else if (cardToLeftId >= 0) {
      nextCard = this.playingCards.findNextCardInSameSuit(cardToLeftId);
      cardLocn = this.getLocnOfCard(nextCard);
      if (nextCard >= 0) {
        validMoves.push([[cardLocn[1], cardLocn[2]], [spaceRow, spaceCol]]);
      }
    }
    return validMoves;
  };

  GameBoard.prototype.moveValidCardToEmptyPlace = function(toCardId) {
    var cardCol, cardRow, cardToLeftId, clickedCol, clickedRow, fromCardId, ref;
    if (toCardId < 0) {
      ref = this.getCardToLeftInfo(toCardId), cardToLeftId = ref[0], clickedRow = ref[1], clickedCol = ref[2], cardRow = ref[3], cardCol = ref[4];
      if (cardToLeftId === -1) {
        return ["select2", 0, 0, clickedRow, clickedCol];
      }
      if (cardToLeftId >= 0) {
        fromCardId = this.playingCards.findNextCardInSameSuit(cardToLeftId);
        if (fromCardId > 0) {
          return this.moveCard(fromCardId, toCardId);
        }
      }
    }
    return ["none", 0, 0, 0, 0];
  };

  GameBoard.prototype.moveCardIfValid = function(fromCardId, toCardId) {
    var cardCol, cardRow, cardToLeftId, clickedCol, clickedRow, moveOk, ok, ref, ref1, toColIdx, toRowIdx;
    if (toCardId < 0) {
      moveOk = false;
      if (this.playingCards.getCardInfo(fromCardId).rankIdx === this.playingCards.TwoId) {
        ref = this.getLocnOfCard(toCardId), ok = ref[0], toRowIdx = ref[1], toColIdx = ref[2];
        if (ok && toColIdx === 0) {
          moveOk = true;
        }
      } else {
        ref1 = this.getCardToLeftInfo(toCardId), cardToLeftId = ref1[0], clickedRow = ref1[1], clickedCol = ref1[2], cardRow = ref1[3], cardCol = ref1[4];
        if (cardToLeftId >= 0) {
          if (fromCardId === this.playingCards.findNextCardInSameSuit(cardToLeftId)) {
            moveOk = true;
          }
        }
      }
      if (moveOk) {
        return this.moveCard(fromCardId, toCardId);
      }
    }
    return ["none", 0, 0, 0, 0];
  };

  GameBoard.prototype.moveCard = function(fromCardId, toCardId) {
    var fromColIdx, fromRowIdx, gapId, ok, ref, ref1, toColIdx, toRowIdx;
    ref = this.getLocnOfCard(fromCardId), ok = ref[0], fromRowIdx = ref[1], fromColIdx = ref[2];
    if (ok) {
      ref1 = this.getLocnOfCard(toCardId), ok = ref1[0], toRowIdx = ref1[1], toColIdx = ref1[2];
      if (ok) {
        gapId = this.board[toRowIdx * this.numCols + toColIdx];
        this.board[toRowIdx * this.numCols + toColIdx] = this.board[fromRowIdx * this.numCols + fromColIdx];
        this.board[fromRowIdx * this.numCols + fromColIdx] = gapId;
        return ["ok", fromRowIdx, fromColIdx, toRowIdx, toColIdx];
      }
    }
    return ["none", 0, 0, 0, 0];
  };

  GameBoard.prototype.moveCardUsingRowAndColInfo = function(fromRowCol, toRowCol) {
    var gapId;
    gapId = this.board[toRowCol[0] * this.numCols + toRowCol[1]];
    this.board[toRowCol[0] * this.numCols + toRowCol[1]] = this.board[fromRowCol[0] * this.numCols + fromRowCol[1]];
    this.board[fromRowCol[0] * this.numCols + fromRowCol[1]] = gapId;
    return ["ok", fromRowCol[0], fromRowCol[1], toRowCol[0], toRowCol[1]];
  };

  GameBoard.prototype.getCardName = function(cardId) {};

  GameBoard.prototype.debugDump = function(debugStr) {
    var cardInfo, col, i, j, ref, ref1, results, row, rowStr;
    console.log(debugStr);
    results = [];
    for (row = i = 0, ref = this.numRows - 1; 0 <= ref ? i <= ref : i >= ref; row = 0 <= ref ? ++i : --i) {
      rowStr = "";
      for (col = j = 0, ref1 = this.numCols - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; col = 0 <= ref1 ? ++j : --j) {
        cardInfo = this.playingCards.getCardInfo(this.getCardId(row, col));
        rowStr += cardInfo.cardShortName + " ";
      }
      results.push(console.log(rowStr));
    }
    return results;
  };

  GameBoard.prototype.getBoardScore = function() {
    var cardId, col, completeRows, factoredScore, i, j, k, kingLastColumns, kingSpaces, l, lastCardWasKing, rawScore, ref, ref1, ref2, ref3, row, rowSuit;
    rawScore = 0;
    completeRows = 0;
    for (row = i = 0, ref = this.numRows - 1; 0 <= ref ? i <= ref : i >= ref; row = 0 <= ref ? ++i : --i) {
      rowSuit = -1;
      for (col = j = 0, ref1 = this.numCols - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; col = 0 <= ref1 ? ++j : --j) {
        cardId = this.getCardId(row, col);
        if (col === 0) {
          if (this.playingCards.getCardRank(cardId) === this.playingCards.TwoId) {
            rowSuit = this.playingCards.getCardSuit(cardId);
            rawScore++;
          } else {
            break;
          }
        } else {
          if (this.playingCards.getCardRank(cardId) === col + 1 && this.playingCards.getCardSuit(cardId) === rowSuit) {
            rawScore++;
            if (col === this.numCols - 1) {
              completeRows++;
            }
          } else {
            break;
          }
        }
      }
    }
    kingSpaces = 0;
    kingLastColumns = 0;
    for (row = k = 0, ref2 = this.numRows - 1; 0 <= ref2 ? k <= ref2 : k >= ref2; row = 0 <= ref2 ? ++k : --k) {
      lastCardWasKing = false;
      for (col = l = 0, ref3 = this.numCols - 1; 0 <= ref3 ? l <= ref3 : l >= ref3; col = 0 <= ref3 ? ++l : --l) {
        cardId = this.getCardId(row, col);
        if (this.playingCards.getCardRank(cardId) === this.playingCards.KingId) {
          if (col === this.numCols - 1) {
            kingLastColumns++;
          } else {
            lastCardWasKing = true;
          }
        } else {
          if (cardId < 0 && lastCardWasKing) {
            kingSpaces++;
          }
          lastCardWasKing = false;
        }
      }
    }
    if (completeRows === 4) {
      factoredScore = 100;
    } else {
      factoredScore = rawScore - kingSpaces + kingLastColumns + completeRows * 5;
    }
    return [factoredScore, rawScore];
  };

  return GameBoard;

})();

//# sourceMappingURL=GameBoard.js.map
