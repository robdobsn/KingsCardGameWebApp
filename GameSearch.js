// Generated by CoffeeScript 1.12.7
var GameSearch;

GameSearch = (function() {
  function GameSearch() {
    this.bestFactoredScore = -10000;
    this.bestMoveList = [];
    this.maxRecurseDepth = 12;
    this.movesConsidered = 0;
    this.maxMovesToConsider = 200000;
  }

  GameSearch.prototype.getPossibleMoves = function(gameBoard) {
    var i, len, moveOptions, mtId, ref;
    moveOptions = [];
    ref = [-1, -2, -3, -4];
    for (i = 0, len = ref.length; i < len; i++) {
      mtId = ref[i];
      moveOptions = moveOptions.concat(gameBoard.getValidMovesForEmptySq(mtId));
    }
    return moveOptions;
  };

  GameSearch.prototype.getDynamicTree = function(startBoard, displayBoard) {
    var bestMove, dynamicBoard, dynamicIncrements, i, j, len, newBoard, newMoveList, newScore, possMove, possMoveIdx, possMoves;
    this.dynamicMoveList = [];
    this.dynamicFactoredScore = -10000;
    this.maxRecurseDepth = 15;
    this.maxMovesToConsider = 2000000;
    dynamicBoard = startBoard.clone();
    for (dynamicIncrements = i = 0; i <= 100; dynamicIncrements = ++i) {
      console.log("Dynamic tree " + dynamicIncrements);
      this.bestFactoredScore = -10000;
      this.bestMoveList = [];
      possMoves = this.getPossibleMoves(dynamicBoard);
      for (possMoveIdx = j = 0, len = possMoves.length; j < len; possMoveIdx = ++j) {
        possMove = possMoves[possMoveIdx];
        this.movesConsidered = 0;
        newBoard = dynamicBoard.clone();
        newBoard.moveCardUsingRowAndColInfo(possMove[0], possMove[1]);
        newMoveList = [possMove];
        newScore = newBoard.getBoardScore();
        if (this.bestFactoredScore < newScore[0]) {
          this.bestFactoredScore = newScore[0];
          this.bestMoveList = newMoveList.slice(0);
        }
        this.treeFromHere(newBoard, newMoveList, 1);
        console.log("Start move " + possMoveIdx + " considered " + this.movesConsidered);
      }
      if (this.bestMoveList.length <= 0) {
        break;
      }
      bestMove = this.bestMoveList[0];
      this.dynamicMoveList.push(bestMove);
      this.dynamicFactoredScore = this.bestFactoredScore;
      dynamicBoard.moveCardUsingRowAndColInfo(bestMove[0], bestMove[1]);
      if (this.maxRecurseDepth > 10) {
        this.maxRecurseDepth--;
        this.maxMovesToConsider -= 200000;
      }
      if (displayBoard === !null) {
        displayBoard.showMoveSequence(this.dynamicMoveList, this.dynamicFactoredScore, 0, true);
      }
    }
    this.bestMoveList = this.dynamicMoveList.slice(0);
    this.bestFactoredScore = this.dynamicFactoredScore;
    return [this.dynamicMoveList, this.dynamicFactoredScore];
  };

  GameSearch.prototype.getFullTreeByInitalMove = function(startBoard) {
    var i, len, newBoard, newMoveList, newScore, possMove, possMoveIdx, possMoves;
    this.bestFactoredScore = -10000;
    this.bestMoveList = [];
    possMoves = this.getPossibleMoves(startBoard);
    for (possMoveIdx = i = 0, len = possMoves.length; i < len; possMoveIdx = ++i) {
      possMove = possMoves[possMoveIdx];
      this.movesConsidered = 0;
      newBoard = new GameBoard(startBoard.playingCards);
      newBoard.copy(startBoard);
      newBoard.moveCardUsingRowAndColInfo(possMove[0], possMove[1]);
      newMoveList = [possMove];
      newScore = newBoard.getBoardScore();
      if (this.bestFactoredScore < newScore[0]) {
        this.bestFactoredScore = newScore[0];
        this.bestMoveList = newMoveList.slice(0);
      }
      this.treeFromHere(newBoard, newMoveList, 1);
      console.log("Start move " + possMoveIdx + " considered " + this.movesConsidered);
    }
    return [this.bestMoveList, this.bestFactoredScore];
  };

  GameSearch.prototype.treeFromHere = function(startBoard, pastMoveList, recurseDepth) {
    var i, len, newBoard, newMoveList, newScore, possMove, possMoves;
    if (recurseDepth >= this.maxRecurseDepth) {
      return;
    }
    possMoves = this.getPossibleMoves(startBoard);
    this.movesConsidered += possMoves.length;
    if (this.movesConsidered > this.maxMovesToConsider) {
      return;
    }
    for (i = 0, len = possMoves.length; i < len; i++) {
      possMove = possMoves[i];
      newBoard = new GameBoard(startBoard.playingCards);
      newBoard.copy(startBoard);
      newBoard.moveCardUsingRowAndColInfo(possMove[0], possMove[1]);
      newMoveList = pastMoveList.slice(0);
      newMoveList.push(possMove);
      newScore = newBoard.getBoardScore();
      if (this.bestFactoredScore < newScore[0]) {
        this.bestFactoredScore = newScore[0];
        this.bestMoveList = newMoveList.slice(0);
      }
      this.treeFromHere(newBoard, newMoveList, recurseDepth + 1);
    }
  };

  GameSearch.prototype.getBestMoves = function() {
    return [this.bestMoveList, this.bestFactoredScore];
  };

  return GameSearch;

})();

//# sourceMappingURL=GameSearch.js.map
