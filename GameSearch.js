// Generated by CoffeeScript 1.10.0
var GameSearch;

GameSearch = (function() {
  function GameSearch() {
    this.searchDepthAtLayer = [13, 12, 12, 11, 11, 11, 11, 11, 10, 9, 8, 7];
    this.maxMovesAtLayer = [500000, 500000, 500000, 250000, 100000];
    this.bestFactoredScore = -10000;
    this.bestMoveList = [];
    this.maxRecurseDepth = 12;
    this.movesConsidered = 0;
    this.maxMovesToConsider = 200000;
  }

  GameSearch.prototype.getPossibleMoves = function(gameBoard) {
    var i, moveOptions, mtIdx;
    moveOptions = [];
    for (mtIdx = i = 0; i <= 3; mtIdx = ++i) {
      moveOptions = moveOptions.concat(gameBoard.getValidMovesForEmptySq(mtIdx));
    }
    return moveOptions;
  };

  GameSearch.prototype.getDynamicTree = function(startBoard, displayBoard) {
    var bestMove, dynIdx, dynamicBoard, i, j, len, newBoard, newMoveList, newScore, possMove, possMoveIdx, possMoves;
    this.dynamicMoveList = [];
    this.dynamicFactoredScore = -10000;
    dynamicBoard = startBoard.clone();
    for (dynIdx = i = 0; i <= 100; dynIdx = ++i) {
      console.log("Dynamic tree " + dynIdx);
      this.maxRecurseDepth = this.searchDepthAtLayer.length > dynIdx ? this.searchDepthAtLayer[dynIdx] : this.searchDepthAtLayer[this.searchDepthAtLayer.length - 1];
      this.maxMovesToConsider = this.maxMovesAtLayer.length > dynIdx ? this.maxMovesAtLayer[dynIdx] : this.maxMovesAtLayer[this.maxMovesAtLayer.length - 1];
      this.bestFactoredScore = -10000;
      this.bestMoveList = [];
      possMoves = this.getPossibleMoves(dynamicBoard);
      for (possMoveIdx = j = 0, len = possMoves.length; j < len; possMoveIdx = ++j) {
        possMove = possMoves[possMoveIdx];
        this.movesConsidered = 0;
        newBoard = dynamicBoard.clone();
        newBoard.moveCardUsingRowAndColInfo(possMove[0], possMove[1]);
        newMoveList = [possMove];
        newScore = newBoard.getScore();
        if (this.bestFactoredScore < newScore) {
          this.bestFactoredScore = newScore;
          this.bestMoveList = newMoveList.slice(0);
        }
        this.treeFromHere(newBoard, newMoveList, 1);
        console.log("Start move " + possMoveIdx + " considered " + this.movesConsidered);
      }
      if (this.bestMoveList.length <= 0) {
        break;
      }
      bestMove = this.bestMoveList[0];
      this.dynamicMoveList.push(bestMove);
      this.dynamicFactoredScore = this.bestFactoredScore;
      dynamicBoard.moveCardUsingRowAndColInfo(bestMove[0], bestMove[1]);
      if (displayBoard === !null) {
        displayBoard.showMoveSequence(this.dynamicMoveList, this.dynamicFactoredScore, 0, true);
      }
    }
    this.bestMoveList = this.dynamicMoveList.slice(0);
    this.bestFactoredScore = this.dynamicFactoredScore;
    return [this.dynamicMoveList, this.dynamicFactoredScore];
  };

  GameSearch.prototype.getFullTreeByInitalMove = function(startBoard) {
    var i, len, newBoard, newMoveList, newScore, possMove, possMoveIdx, possMoves;
    this.bestFactoredScore = -10000;
    this.bestMoveList = [];
    possMoves = this.getPossibleMoves(startBoard);
    for (possMoveIdx = i = 0, len = possMoves.length; i < len; possMoveIdx = ++i) {
      possMove = possMoves[possMoveIdx];
      this.movesConsidered = 0;
      newBoard = new GameBoard(startBoard.playingCards);
      newBoard.copy(startBoard);
      newBoard.moveCardUsingRowAndColInfo(possMove[0], possMove[1]);
      newMoveList = [possMove];
      newScore = newBoard.getScore();
      if (this.bestFactoredScore < newScore) {
        this.bestFactoredScore = newScore;
        this.bestMoveList = newMoveList.slice(0);
      }
      this.treeFromHere(newBoard, newMoveList, 1);
      console.log("Start move " + possMoveIdx + " considered " + this.movesConsidered);
    }
    return [this.bestMoveList, this.bestFactoredScore];
  };

  GameSearch.prototype.treeFromHere = function(startBoard, pastMoveList, recurseDepth) {
    var i, len, newBoard, newMoveList, newScore, possMove, possMoves;
    if (recurseDepth >= this.maxRecurseDepth) {
      return;
    }
    possMoves = this.getPossibleMoves(startBoard);
    this.movesConsidered += possMoves.length;
    if (this.movesConsidered > this.maxMovesToConsider) {
      return;
    }
    for (i = 0, len = possMoves.length; i < len; i++) {
      possMove = possMoves[i];
      newBoard = new GameBoard(startBoard.playingCards);
      newBoard.copy(startBoard);
      newBoard.moveCardUsingRowAndColInfo(possMove[0], possMove[1]);
      newMoveList = pastMoveList.slice(0);
      newMoveList.push(possMove);
      newScore = newBoard.getScore();
      if (this.bestFactoredScore < newScore) {
        this.bestFactoredScore = newScore;
        this.bestMoveList = newMoveList.slice(0);
      }
      this.treeFromHere(newBoard, newMoveList, recurseDepth + 1);
    }
  };

  GameSearch.prototype.getBestMoves = function() {
    return [this.bestMoveList, this.bestFactoredScore];
  };

  return GameSearch;

})();

//# sourceMappingURL=GameSearch.js.map
