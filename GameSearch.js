// Generated by CoffeeScript 1.12.7
var GameSearch;

GameSearch = (function() {
  function GameSearch() {
    this.bestFactoredScore = -10000;
    this.bestMoveList = [];
    this.maxRecurseDepth = 15;
    this.movesConsidered = 0;
    this.maxMovesToConsider = 1000000;
  }

  GameSearch.prototype.getPossibleMoves = function(gameBoard) {
    var i, len, moveOptions, mtId, ref;
    moveOptions = [];
    ref = [-1, -2, -3, -4];
    for (i = 0, len = ref.length; i < len; i++) {
      mtId = ref[i];
      moveOptions = moveOptions.concat(gameBoard.getValidMovesForEmptySq(mtId));
    }
    return moveOptions;
  };

  GameSearch.prototype.getFullTreeByInitalMove = function(startBoard) {
    var i, len, newBoard, newMoveList, newScore, possMove, possMoveIdx, possMoves;
    this.bestFactoredScore = -10000;
    this.bestMoveList = [];
    possMoves = this.getPossibleMoves(startBoard);
    for (possMoveIdx = i = 0, len = possMoves.length; i < len; possMoveIdx = ++i) {
      possMove = possMoves[possMoveIdx];
      this.movesConsidered = 0;
      newBoard = new GameBoard(startBoard.playingCards);
      newBoard.copy(startBoard);
      newBoard.moveCardUsingRowAndColInfo(possMove[0], possMove[1]);
      newMoveList = [possMove];
      newScore = newBoard.getBoardScore();
      if (this.bestFactoredScore < newScore[0]) {
        this.bestFactoredScore = newScore[0];
        this.bestMoveList = newMoveList.slice(0);
      }
      this.treeFromHere(newBoard, newMoveList, 1);
      console.log("Start move " + possMoveIdx + " considered " + this.movesConsidered);
    }
    return [this.bestMoveList, this.bestFactoredScore];
  };

  GameSearch.prototype.treeFromHere = function(startBoard, pastMoveList, recurseDepth) {
    var i, len, newBoard, newMoveList, newScore, possMove, possMoves;
    if (recurseDepth >= this.maxRecurseDepth) {
      return;
    }
    possMoves = this.getPossibleMoves(startBoard);
    this.movesConsidered += possMoves.length;
    if (this.movesConsidered > this.maxMovesToConsider) {
      return;
    }
    for (i = 0, len = possMoves.length; i < len; i++) {
      possMove = possMoves[i];
      newBoard = new GameBoard(startBoard.playingCards);
      newBoard.copy(startBoard);
      newBoard.moveCardUsingRowAndColInfo(possMove[0], possMove[1]);
      newMoveList = pastMoveList.slice(0);
      newMoveList.push(possMove);
      newScore = newBoard.getBoardScore();
      if (this.bestFactoredScore < newScore[0]) {
        this.bestFactoredScore = newScore[0];
        this.bestMoveList = newMoveList.slice(0);
      }
      this.treeFromHere(newBoard, newMoveList, recurseDepth + 1);
    }
  };

  GameSearch.prototype.getBestMoves = function() {
    return [this.bestMoveList, this.bestFactoredScore];
  };

  return GameSearch;

})();

//# sourceMappingURL=GameSearch.js.map
