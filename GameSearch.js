// Generated by CoffeeScript 1.12.7
var GameSearch;

GameSearch = (function() {
  function GameSearch() {
    this.searchDepthAtLayer = [13, 12, 12, 11, 11, 11, 11, 11, 10, 9, 8, 7];
    this.maxMovesAtLayer = [500000, 500000, 500000, 250000, 100000];
    this.bestFactoredScore = -10000;
    this.bestMoveList = [];
    this.maxRecurseDepth = 12;
    this.movesConsidered = 0;
    this.maxMovesToConsider = 200000;
  }

  GameSearch.prototype.getPossibleMoves = function(gameBoard) {
    var j, moveOptions, mtIdx;
    moveOptions = [];
    for (mtIdx = j = 0; j <= 3; mtIdx = ++j) {
      moveOptions = moveOptions.concat(gameBoard.getValidMovesForEmptySq(mtIdx));
    }
    return moveOptions;
  };

  GameSearch.prototype.getDynamicTree = function(startBoard, displayBoard) {
    var bestMove, dynIdx, dynamicBoard, j, k, len, newBoard, newMoveList, newScore, possMove, possMoveIdx, possMoves;
    this.dynamicMoveList = [];
    this.dynamicFactoredScore = -10000;
    dynamicBoard = startBoard.clone();
    for (dynIdx = j = 0; j <= 100; dynIdx = ++j) {
      console.log("Dynamic tree " + dynIdx);
      this.maxRecurseDepth = this.searchDepthAtLayer.length > dynIdx ? this.searchDepthAtLayer[dynIdx] : this.searchDepthAtLayer[this.searchDepthAtLayer.length - 1];
      this.maxMovesToConsider = this.maxMovesAtLayer.length > dynIdx ? this.maxMovesAtLayer[dynIdx] : this.maxMovesAtLayer[this.maxMovesAtLayer.length - 1];
      this.bestFactoredScore = -10000;
      this.bestMoveList = [];
      possMoves = this.getPossibleMoves(dynamicBoard);
      for (possMoveIdx = k = 0, len = possMoves.length; k < len; possMoveIdx = ++k) {
        possMove = possMoves[possMoveIdx];
        this.movesConsidered = 0;
        newBoard = dynamicBoard.clone();
        newBoard.moveCardUsingRowAndColInfo(possMove[0], possMove[1]);
        newMoveList = [possMove];
        newScore = newBoard.getScore();
        if (this.bestFactoredScore < newScore) {
          this.bestFactoredScore = newScore;
          this.bestMoveList = newMoveList.slice(0);
        }
        this.treeFromHere(newBoard, newMoveList, 1);
        console.log("Start move " + possMoveIdx + " considered " + this.movesConsidered);
      }
      if (this.bestMoveList.length <= 0) {
        break;
      }
      bestMove = this.bestMoveList[0];
      this.dynamicMoveList.push(bestMove);
      this.dynamicFactoredScore = this.bestFactoredScore;
      dynamicBoard.moveCardUsingRowAndColInfo(bestMove[0], bestMove[1]);
      if (displayBoard === !null) {
        displayBoard.showMoveSequence(this.dynamicMoveList, this.dynamicFactoredScore, 0, true);
      }
    }
    this.bestMoveList = this.dynamicMoveList.slice(0);
    this.bestFactoredScore = this.dynamicFactoredScore;
    return [this.bestMoveList, this.bestFactoredScore];
  };

  GameSearch.prototype.getFullTreeByInitalMove = function(startBoard) {
    var j, len, newBoard, newMoveList, newScore, possMove, possMoveIdx, possMoves;
    this.bestFactoredScore = -10000;
    this.bestMoveList = [];
    possMoves = this.getPossibleMoves(startBoard);
    for (possMoveIdx = j = 0, len = possMoves.length; j < len; possMoveIdx = ++j) {
      possMove = possMoves[possMoveIdx];
      this.movesConsidered = 0;
      newBoard = new GameBoard(startBoard.playingCards);
      newBoard.copy(startBoard);
      newBoard.moveCardUsingRowAndColInfo(possMove[0], possMove[1]);
      newMoveList = [possMove];
      newScore = newBoard.getScore();
      if (this.bestFactoredScore < newScore) {
        this.bestFactoredScore = newScore;
        this.bestMoveList = newMoveList.slice(0);
      }
      this.treeFromHere(newBoard, newMoveList, 1);
      console.log("Start move " + possMoveIdx + " considered " + this.movesConsidered);
    }
    return [this.bestMoveList, this.bestFactoredScore];
  };

  GameSearch.prototype.treeFromHere = function(startBoard, pastMoveList, recurseDepth) {
    var j, len, newBoard, newMoveList, newScore, possMove, possMoves;
    if (recurseDepth >= this.maxRecurseDepth) {
      return;
    }
    possMoves = this.getPossibleMoves(startBoard);
    this.movesConsidered += possMoves.length;
    if (this.movesConsidered > this.maxMovesToConsider) {
      return;
    }
    for (j = 0, len = possMoves.length; j < len; j++) {
      possMove = possMoves[j];
      newBoard = new GameBoard(startBoard.playingCards);
      newBoard.copy(startBoard);
      newBoard.moveCardUsingRowAndColInfo(possMove[0], possMove[1]);
      newMoveList = pastMoveList.slice(0);
      newMoveList.push(possMove);
      newScore = newBoard.getScore();
      if (this.bestFactoredScore < newScore) {
        this.bestFactoredScore = newScore;
        this.bestMoveList = newMoveList.slice(0);
      }
      this.treeFromHere(newBoard, newMoveList, recurseDepth + 1);
    }
  };

  GameSearch.prototype.getBestMoves = function() {
    return [this.bestMoveList, this.bestFactoredScore];
  };

  GameSearch.prototype.getLoop = function(gameBoard, displayBoard, startCardId) {
    var cardCol, cardRow, cardToRightId, curCardId, curCardLocn, i, j, moveList, prevCardCol, prevCardId, prevCardRow, prevCardStr, ref;
    moveList = [];
    curCardId = startCardId;
    for (i = j = 0; j <= 100; i = ++j) {
      if (gameBoard.isGap(curCardId)) {
        console.log("Current card is a gap");
        break;
      }
      curCardLocn = gameBoard.getLocnOfCard(curCardId);
      prevCardId = gameBoard.getIdOfPrevCard(curCardId);
      prevCardStr = prevCardId >= 0 ? PlayingCards.getCardInfo(prevCardId).cardShortName : "INVALID";
      console.log("cur card " + PlayingCards.getCardInfo(curCardId).cardShortName + ", prev " + prevCardStr);
      if (prevCardId < 0) {
        console.log("prev card is 2 or error");
        break;
      }
      ref = gameBoard.getCardToRightInfo(prevCardId), cardToRightId = ref[0], prevCardRow = ref[1], prevCardCol = ref[2], cardRow = ref[3], cardCol = ref[4];
      if (cardToRightId < 0) {
        console.log("prev card at end of row");
        break;
      }
      moveList.push([[curCardLocn[1], curCardLocn[2]], [cardRow, cardCol]]);
      curCardId = cardToRightId;
    }
    return moveList;
  };

  return GameSearch;

})();

//# sourceMappingURL=GameSearch.js.map
